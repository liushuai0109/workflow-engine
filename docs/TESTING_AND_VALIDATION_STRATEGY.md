# 代码验证与测试策略方案

## 问题描述

当前存在的问题：
1. AI修改代码后，前端浏览器运行报错
2. 后端服务启动失败
3. 前端访问接口报错
4. 缺少自动化验证机制，导致问题在交付前未被发现

## 解决方案架构

### 一、AI预设提示词层面（.cursorrules / AGENTS.md）

#### 1.1 强制验证检查清单（遵循TDD原则）

在AI进行任何代码修改前，必须遵循TDD（测试驱动开发）原则：

**修改代码前（TDD Red阶段）：**
- [ ] 为新功能创建或更新对应的测试用例
  - [ ] 单元测试（必须）
  - [ ] 集成测试（如涉及多模块交互）
  - [ ] E2E测试（如涉及用户可见功能或关键业务流程）
- [ ] 运行测试确认测试失败（Red阶段验证）
- [ ] 确认测试用例覆盖了所有需求场景

**前端代码修改后（TDD Green阶段）：**
- [ ] 运行 `cd client && npm run type-check` 进行类型检查
- [ ] 运行 `cd client && npm run build` 确保代码可以编译
- [ ] 运行 `cd client && npm run test` 确保所有单元测试通过（包括新创建的测试）
- [ ] 运行 `cd client && npm run test:e2e:headless` 进行headless browser验证
- [ ] 验证前端服务可以正常启动（至少启动5秒无错误）
- [ ] 确认所有测试用例通过（Green阶段验证）

**后端代码修改后（TDD Green阶段）：**
- [ ] 运行 `cd server && go build ./cmd/server/main.go` 确保代码可以编译
- [ ] 运行 `cd server && make test` 确保所有单元测试通过（包括新创建的测试）
- [ ] 验证后端服务可以正常启动（至少启动5秒无错误）
- [ ] 运行健康检查接口验证服务可用性
- [ ] 确认所有测试用例通过（Green阶段验证）

**接口修改后：**
- [ ] 运行完整的E2E测试套件（包括新创建的E2E测试）
- [ ] 验证前端可以正常调用后端接口
- [ ] 验证错误处理逻辑正确
- [ ] 确认所有测试用例通过

**代码重构后（TDD Refactor阶段，可选）：**
- [ ] 运行所有测试确保重构未破坏功能
- [ ] 验证代码质量和可读性提升

#### 1.2 代码修改工作流（遵循TDD测试驱动开发）

AI在修改代码时必须遵循TDD（Test-Driven Development）开发范式，工作流如下：

```
1. 创建或修改测试用例（Red阶段）
   ├─ 新功能：创建对应的单元测试、集成测试、E2E测试
   ├─ 修改功能：更新现有测试用例以反映新需求
   └─ 运行测试确认失败（Red）→ 继续
   
2. 修改代码实现功能（Green阶段）
   ├─ 实现最小化代码让测试通过
   ├─ 运行基础验证（编译/类型检查）
   │  ├─ 失败 → 修复问题 → 重新验证
   │  └─ 成功 → 继续
   └─ 运行测试确认通过（Green）→ 继续
   
3. 运行完整测试套件
   ├─ 运行单元测试
   │  ├─ 失败 → 修复问题 → 重新运行
   │  └─ 成功 → 继续
   ├─ 运行集成测试（如果涉及）
   │  ├─ 失败 → 修复问题 → 重新运行
   │  └─ 成功 → 继续
   └─ 运行E2E测试（如果涉及接口或关键功能）
      ├─ 失败 → 修复问题 → 重新运行
      └─ 成功 → 继续
   
4. 运行集成验证（启动服务/headless browser）
   ├─ 启动前端服务验证
   │  ├─ 失败 → 修复问题 → 重新验证
   │  └─ 成功 → 继续
   ├─ 启动后端服务验证
   │  ├─ 失败 → 修复问题 → 重新验证
   │  └─ 成功 → 继续
   └─ Headless browser验证（前端）
      ├─ 失败 → 修复问题 → 重新验证
      └─ 成功 → 继续
   
5. 重构代码（Refactor阶段，可选）
   ├─ 优化代码结构
   ├─ 提升代码可读性
   ├─ 运行所有测试确保重构未破坏功能
   └─ 成功 → 完成
```

**TDD原则说明：**
- **Red（红）**：先写测试，测试应该失败（因为功能还未实现）
- **Green（绿）**：写最小化代码让测试通过
- **Refactor（重构）**：优化代码，保持测试通过

**测试用例优先级：**
1. **单元测试**：必须为所有新功能/修改创建单元测试
2. **集成测试**：涉及多个模块交互时创建集成测试
3. **E2E测试**：涉及用户可见功能或关键业务流程时创建E2E测试

#### 1.3 验证失败处理

如果验证失败，AI必须：
1. **立即停止**进一步的代码修改
2. **分析错误信息**，定位问题根源
3. **修复问题**，而不是继续添加新功能
4. **重新运行验证**，确保问题已解决
5. **报告验证结果**，包括：
   - 验证步骤
   - 失败原因
   - 修复方案
   - 验证通过确认

### 二、测试架构层面

#### 2.1 前端测试架构

**2.1.1 单元测试（已存在，需增强）**
- 工具：Jest + @vue/test-utils
- 覆盖范围：所有服务层、工具函数、组件逻辑
- 运行命令：`npm run test`
- 目标覆盖率：> 70%

**2.1.2 类型检查（已存在，需强制）**
- 工具：vue-tsc
- 运行命令：`npm run type-check`
- 要求：零类型错误

**2.1.3 构建验证（需添加）**
- 工具：Vite build
- 运行命令：`npm run build`
- 要求：构建成功，无警告

**2.1.4 Headless Browser验证（需添加）**
- 工具：Playwright
- 目的：验证应用可以在headless浏览器中正常启动和运行
- 运行命令：`npm run test:e2e:headless`
- 测试内容：
  - 应用可以正常加载
  - 主要路由可以访问
  - 关键组件可以渲染
  - 无JavaScript运行时错误

**2.1.5 服务启动验证（需添加）**
- 工具：自定义脚本
- 目的：验证开发服务器可以正常启动
- 运行命令：`npm run verify:start`
- 验证内容：
  - 服务器在5秒内启动
  - 无启动错误
  - 可以访问根路径
  - 可以访问主要路由

#### 2.2 后端测试架构

**2.2.1 单元测试（已存在，需增强）**
- 工具：Go testing
- 覆盖范围：所有业务逻辑、服务层、处理器
- 运行命令：`make test`
- 目标覆盖率：> 70%

**2.2.2 编译验证（需强制）**
- 工具：Go compiler
- 运行命令：`go build ./cmd/server/main.go`
- 要求：编译成功，无错误

**2.2.3 服务启动验证（需添加）**
- 工具：自定义脚本
- 目的：验证服务器可以正常启动
- 运行命令：`make verify:start`
- 验证内容：
  - 服务器在10秒内启动
  - 无启动错误
  - 健康检查接口返回200
  - 数据库连接正常（如果配置了数据库）

**2.2.4 集成测试（已存在，需增强）**
- 工具：Go testing with tags
- 运行命令：`make test-integration`
- 要求：所有集成测试通过

#### 2.3 E2E测试架构

**2.3.1 测试框架**
- 工具：Playwright
- 配置：独立的Playwright配置文件
- 测试目录：`tests/e2e/`

**2.3.2 测试覆盖范围**

**核心功能测试：**
- [ ] 应用启动和路由导航
- [ ] BPMN编辑器加载和基本操作
- [ ] 工作流创建、编辑、保存
- [ ] 工作流执行和状态跟踪
- [ ] 用户认证和授权（如果有）
- [ ] 聊天功能（如果有）
- [ ] 数据持久化

**接口集成测试：**
- [ ] 前端调用后端API
- [ ] 错误处理和错误消息显示
- [ ] 数据格式验证
- [ ] 并发请求处理

**回归测试：**
- [ ] 之前修复的bug不会重现
- [ ] 关键业务流程完整性
- [ ] 性能基准测试

**2.3.3 测试环境**
- 前端：开发服务器（`npm run start`）
- 后端：测试服务器（`make run`）
- 数据库：测试数据库（可选，用于集成测试）

**2.3.4 测试执行策略**
- **快速测试**：每次代码修改后运行（< 2分钟）
- **完整测试**：提交前运行（< 10分钟）
- **完整测试套件**：CI/CD中运行（< 30分钟）

### 三、持续集成/持续测试架构

#### 3.1 本地预提交钩子（Pre-commit Hooks）

**工具：** Husky + lint-staged

**执行时机：** Git commit之前

**执行内容：**
1. 前端类型检查
2. 前端单元测试（快速模式）
3. 后端编译验证
4. 后端单元测试（快速模式）
5. 代码格式化检查

#### 3.2 本地验证脚本

**工具：** 自定义Shell脚本

**脚本：** `scripts/verify-all.sh`

**执行内容：**
1. 前端验证
   - 类型检查
   - 构建验证
   - 单元测试
   - Headless browser验证
2. 后端验证
   - 编译验证
   - 单元测试
   - 服务启动验证
3. E2E测试（快速模式）
4. 生成验证报告

#### 3.3 CI/CD流水线（GitHub Actions / GitLab CI）

**触发时机：**
- Push到任何分支
- Pull Request创建/更新
- 定时运行（每日）

**流水线阶段：**

**Stage 1: 基础验证（5-10分钟）**
- 前端类型检查
- 前端构建
- 后端编译
- 前端单元测试
- 后端单元测试

**Stage 2: 服务启动验证（2-5分钟）**
- 启动前端服务
- 启动后端服务
- 健康检查
- 基础功能验证

**Stage 3: E2E测试（10-30分钟）**
- 完整E2E测试套件
- 接口集成测试
- 回归测试

**Stage 4: 测试报告（1-2分钟）**
- 生成测试覆盖率报告
- 生成测试结果报告
- 上传测试报告

#### 3.4 持续监控

**工具：** 可选（如Sentry、DataDog）

**监控内容：**
- 测试通过率趋势
- 测试执行时间趋势
- 代码覆盖率趋势
- 失败测试分析

### 四、实施计划

#### Phase 1: AI预设提示词更新（立即实施）

1. 更新 `.cursorrules` 或 `openspec/AGENTS.md`
   - 添加强制验证检查清单
   - 添加代码修改工作流
   - 添加验证失败处理流程

2. 创建验证脚本模板
   - `scripts/verify-frontend.sh`
   - `scripts/verify-backend.sh`
   - `scripts/verify-all.sh`

#### Phase 2: 前端测试增强（1-2天）

1. 添加Playwright配置
   - `playwright.config.ts`
   - 安装Playwright依赖

2. 实现Headless Browser验证
   - 基础启动验证测试
   - 路由导航测试
   - 关键组件渲染测试

3. 实现服务启动验证脚本
   - `client/scripts/verify-start.sh`

4. 更新package.json脚本
   - `test:e2e:headless`
   - `verify:start`
   - `verify:all`

#### Phase 3: 后端测试增强（1-2天）

1. 实现服务启动验证脚本
   - `server/scripts/verify-start.sh`

2. 更新Makefile
   - `verify:start`
   - `verify:build`
   - `verify:all`

3. 增强单元测试覆盖率

#### Phase 4: E2E测试完善（3-5天）

1. 完善Playwright配置
   - 测试环境配置
   - 测试数据管理
   - 测试报告配置

2. 实现核心功能E2E测试
   - BPMN编辑器操作
   - 工作流管理
   - 接口调用

3. 实现回归测试套件
   - 历史bug回归测试
   - 关键业务流程测试

4. 实现测试数据管理
   - 测试数据准备
   - 测试数据清理

#### Phase 5: CI/CD集成（2-3天）

1. 配置GitHub Actions或GitLab CI
   - 基础验证阶段
   - 服务启动验证阶段
   - E2E测试阶段
   - 报告生成阶段

2. 配置预提交钩子（可选）
   - Husky配置
   - lint-staged配置

3. 配置测试报告
   - 覆盖率报告
   - 测试结果报告
   - 历史趋势分析

### 五、工具和依赖

#### 5.1 前端工具

```json
{
  "devDependencies": {
    "@playwright/test": "^1.40.0",
    "concurrently": "^8.2.2"
  }
}
```

#### 5.2 后端工具

- Go 1.21+
- Make
- PostgreSQL（用于集成测试）

#### 5.3 CI/CD工具

- GitHub Actions 或 GitLab CI
- Docker（可选，用于测试环境隔离）

### 六、验证标准

#### 6.1 代码修改验证标准

**必须通过：**
- ✅ 类型检查/编译通过
- ✅ 单元测试通过
- ✅ 构建成功
- ✅ 服务可以启动（前端/后端）

**建议通过：**
- ⚠️ E2E测试通过（关键功能）
- ⚠️ 代码覆盖率不下降

#### 6.2 提交前验证标准

**必须通过：**
- ✅ 所有基础验证
- ✅ 快速E2E测试（< 2分钟）
- ✅ 代码格式化

#### 6.3 合并前验证标准

**必须通过：**
- ✅ 所有提交前验证
- ✅ 完整E2E测试套件
- ✅ 代码覆盖率报告
- ✅ 无已知严重bug

### 七、维护和持续改进

#### 7.1 测试维护

- **每周审查**：测试通过率和失败原因
- **每月优化**：慢速测试优化，测试覆盖率提升
- **季度评估**：测试策略有效性评估

#### 7.2 测试数据管理

- 测试数据定期更新
- 测试环境定期清理
- 测试依赖定期更新

#### 7.3 文档更新

- 测试用例文档
- 测试运行指南
- 故障排查指南

### 八、预期效果

实施此方案后，预期达到：

1. **问题发现时间**：从"用户报告"提前到"代码修改后立即发现"
2. **问题修复成本**：降低90%（早期发现，修复成本低）
3. **代码质量**：显著提升（强制验证机制）
4. **开发效率**：提升（减少调试时间）
5. **用户满意度**：提升（减少生产环境bug）

### 九、风险评估和缓解

#### 9.1 风险

1. **测试执行时间过长**
   - 风险：影响开发效率
   - 缓解：分层测试，快速测试优先

2. **测试环境不稳定**
   - 风险：测试结果不可靠
   - 缓解：测试环境隔离，数据清理机制

3. **测试维护成本高**
   - 风险：测试代码难以维护
   - 缓解：测试代码规范，定期重构

#### 9.2 缓解措施

1. 渐进式实施，先实施关键验证
2. 测试分层，快速测试和完整测试分离
3. 测试环境容器化，提高稳定性
4. 定期审查和优化测试策略

## 总结

此方案从AI预设提示词、测试架构、CI/CD三个层面全面解决代码验证问题，确保：

1. **AI修改代码后立即验证**：通过预设提示词强制要求
2. **前端代码可运行**：通过headless browser验证
3. **后端代码可启动**：通过编译和启动验证
4. **接口可用**：通过E2E测试验证
5. **持续保障**：通过CI/CD自动化测试

实施此方案后，将彻底解决"AI修改代码后无法运行"的问题，确保代码质量持续提升。

