# 设计文档：Docker 容器化

## 上下文

当前项目包含三个主要组件：
1. **前端**：Vue 3 + Vite 应用，运行在端口 8000
2. **后端**：Go 应用，运行在端口 3000
3. **数据库**：PostgreSQL，运行在端口 5432

项目需要支持开发和生产两种环境，并且需要简化部署流程。

## 目标 / 非目标

### 目标
- 提供一键启动的开发环境
- 支持生产环境的容器化部署
- 确保开发、测试、生产环境的一致性
- 简化新开发者的环境搭建流程
- 支持服务的独立扩展和更新

### 非目标
- 不强制使用 Docker（保持传统开发方式的兼容性）
- 不包含 CI/CD 流水线配置（后续可扩展）
- 不包含完整的监控和日志收集系统（基础监控包含在 Kubernetes 中）

## 决策

### 决策 1：使用 Kubernetes 进行容器编排

**决策**：使用 Kubernetes 进行容器编排，与主流云原生方案对齐

**理由**：
1. **生产就绪**：Kubernetes 是业界标准的容器编排平台，提供生产级能力
2. **可扩展性**：支持自动扩缩容、滚动更新、服务发现等高级特性
3. **生态成熟**：丰富的工具链和社区支持，便于集成监控、日志、CI/CD
4. **云原生对齐**：与主流云平台（AWS EKS、GKE、AKS）和本地方案（minikube、kind）兼容
5. **未来扩展**：为后续的微服务拆分、多环境管理打下基础

**替代方案考虑**：
- **Docker Compose**：简单但功能有限，不适合生产环境
- **Docker Swarm**：社区支持较少，功能不如 Kubernetes 完善

### 决策 2：多阶段构建优化镜像大小

**决策**：使用多阶段构建，分离构建环境和运行环境

**理由**：
1. **镜像大小**：生产镜像只包含运行时文件，大幅减小镜像体积
2. **安全性**：运行环境不包含构建工具，减少攻击面
3. **性能**：更小的镜像意味着更快的拉取和启动速度

**实现**：
- 前端：构建阶段使用 Node.js，运行阶段使用 Nginx
- 后端：构建阶段使用 Go，运行阶段使用 Alpine Linux

### 决策 3：开发模式支持热重载

**决策**：开发环境使用卷挂载实现源代码热重载

**理由**：
1. **开发效率**：代码修改后自动生效，无需重建镜像
2. **调试便利**：可以直接在容器内查看日志和调试
3. **体验一致**：与本地开发体验保持一致

**实现**：
- 前端：挂载 `client/` 目录，使用 Vite 开发服务器
- 后端：可选挂载 `server/` 目录（需要支持热重载工具如 air）

### 决策 4：数据库迁移策略

**决策**：使用 Kubernetes Job 或 Init Container 运行数据库迁移

**理由**：
1. **可控性**：迁移作为独立任务运行，便于监控和重试
2. **幂等性**：迁移 Job 可以安全地多次运行
3. **灵活性**：可以选择在应用启动前或启动后运行迁移
4. **Kubernetes 原生**：使用 Kubernetes Job 符合最佳实践

**实现方案 A（推荐）**：使用 Init Container
- 后端 Deployment 配置 Init Container
- Init Container 运行迁移脚本
- 迁移成功后主容器才启动

**实现方案 B**：使用独立 Job
- 创建独立的 Migration Job
- 在部署应用前手动或通过 CI/CD 运行
- 使用 `kubectl wait` 等待 Job 完成

**替代方案考虑**：
- **PostgreSQL init 脚本**：简单但难以监控和重试
- **应用启动时迁移**：增加应用启动时间，失败影响应用启动

### 决策 5：环境变量和配置管理

**决策**：使用 Kubernetes ConfigMap 和 Secret 管理配置

**理由**：
1. **安全性**：敏感信息存储在 Secret 中，支持加密
2. **灵活性**：不同环境使用不同的 ConfigMap 和 Secret
3. **动态更新**：支持 ConfigMap 热更新（需要应用支持）
4. **标准化**：符合 Kubernetes 最佳实践

**实现**：
- 非敏感配置存储在 ConfigMap（如数据库主机、端口）
- 敏感信息存储在 Secret（如数据库密码、API Key）
- 使用 Kustomize 或 Helm 管理不同环境的配置
- 提供 `.env.example` 作为本地开发参考

### 决策 6：网络架构和服务发现

**决策**：使用 Kubernetes Service 和 DNS 进行服务发现

**理由**：
1. **服务发现**：Kubernetes DNS 自动为每个 Service 创建 DNS 记录
2. **负载均衡**：Service 提供内置的负载均衡能力
3. **网络策略**：支持 NetworkPolicy 进行细粒度的网络控制
4. **Ingress**：通过 Ingress 统一管理外部访问

**架构**：
```
┌─────────────────────────────────────────┐
│         Kubernetes Cluster              │
│                                         │
│  ┌──────────┐      ┌──────────┐        │
│  │ Ingress  │─────▶│  Client  │        │
│  │          │      │ Service  │        │
│  └──────────┘      └────┬─────┘        │
│                         │              │
│                    ┌────▼─────┐        │
│                    │  Server  │        │
│                    │ Service  │        │
│                    └────┬─────┘        │
│                         │              │
│                    ┌────▼─────┐        │
│                    │   DB     │        │
│                    │ Service  │        │
│                    └──────────┘        │
└─────────────────────────────────────────┘
```

**服务发现机制**：
- 前端通过 `http://server-service:3000` 访问后端
- 后端通过 `postgres-service:5432` 访问数据库
- 外部通过 Ingress 访问前端（如 `http://workflow.example.com`）

## 风险 / 权衡

### 风险 1：数据持久化丢失
**风险**：容器删除时数据卷可能丢失  
**缓解措施**：
- 使用命名卷而非匿名卷
- 定期备份数据库
- 文档中明确说明数据持久化位置

### 风险 2：性能开销
**风险**：容器化可能带来性能开销  
**缓解措施**：
- 开发环境可接受轻微性能损失
- 生产环境使用优化配置
- 监控容器资源使用情况

### 风险 3：Kubernetes 配置复杂
**风险**：Kubernetes 配置相对复杂，学习曲线陡峭  
**缓解措施**：
- 使用 Kustomize 简化配置管理
- 提供详细的配置文档和示例
- 使用 kubectl 命令验证配置
- 提供本地开发环境（minikube/kind）简化测试

### 风险 4：资源管理
**风险**：Kubernetes 需要配置资源限制和请求  
**缓解措施**：
- 为每个容器设置合理的资源请求和限制
- 使用 HPA（Horizontal Pod Autoscaler）自动扩缩容
- 监控资源使用情况，及时调整

### 风险 5：迁移脚本执行顺序
**风险**：数据库迁移脚本执行顺序可能不正确  
**缓解措施**：
- 使用带序号的文件名（如 `000001_*.sql`）
- 验证迁移脚本的幂等性
- 使用 Kubernetes Job 确保迁移顺序
- 提供手动迁移选项

## 迁移计划

### 阶段 1：添加 Docker 和 Kubernetes 支持（不破坏现有流程）
- 创建 Docker 配置文件
- 添加 Kubernetes 配置清单
- 更新文档说明 Kubernetes 使用方式
- **不影响**：现有的本地开发方式继续可用

### 阶段 2：验证和测试
- 在本地 Kubernetes 环境（minikube/kind）验证配置
- 测试所有功能在 Kubernetes 中正常工作
- 验证数据持久化（PersistentVolume）
- 验证服务发现和负载均衡
- 验证健康检查和自动重启
- 性能测试

### 阶段 3：文档和培训
- 更新 README 和开发文档
- 提供 Kubernetes 部署指南
- 提供本地开发环境设置指南（minikube/kind）
- 团队培训（如需要）

### 阶段 4：生产环境部署
- 在目标 Kubernetes 集群（云平台或自建）部署
- 配置 Ingress 和域名
- 配置监控和日志收集
- 配置备份和灾难恢复
- 性能优化和调优

## 未决问题

1. **数据库迁移工具**：是否需要将 migrate 工具集成到后端容器中？
   - 当前方案：使用 PostgreSQL init 脚本
   - 备选方案：后端容器启动时运行迁移

2. **日志管理**：是否需要集中式日志收集？
   - 当前方案：使用 Kubernetes 日志（kubectl logs）
   - 备选方案：集成 ELK Stack、Loki 或云平台日志服务

3. **监控和告警**：是否需要容器监控？
   - 当前方案：使用 Kubernetes 健康检查 + 基础监控
   - 备选方案：集成 Prometheus + Grafana 或云平台监控服务

4. **CI/CD 集成**：是否需要在 CI/CD 中使用 Docker？
   - 当前方案：文档中说明，但不强制
   - 备选方案：创建 GitHub Actions 工作流

