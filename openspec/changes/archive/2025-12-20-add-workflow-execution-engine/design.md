# 工作流执行引擎设计文档

## 上下文

当前系统已经实现了工作流定义、实例和执行的数据模型，但缺少实际的工作流执行引擎。需要实现一个能够：
1. 从指定节点开始执行工作流
2. 调用业务接口（ServiceTask）
3. 根据 BPMN 定义推进流程
4. 返回执行结果

## 目标 / 非目标

### 目标
- 实现基本的工作流执行引擎，支持从指定节点开始执行
- 支持 ServiceTask 节点调用外部业务接口
- 支持基本的流程推进（序列流、条件判断）
- 返回业务接口响应和流程引擎执行状态

### 非目标
- 复杂的网关处理（并行网关的完整实现、事件网关等）
- 子流程执行
- 边界事件处理
- 异步执行（当前为同步执行）
- 工作流版本管理
- 执行历史回放

## 决策

### 决策 1：同步执行模式

**决策**：工作流执行采用同步模式，即接口调用后立即返回执行结果。

**理由**：
- 简化实现，降低复杂度
- 适合简单的业务流程
- 客户端可以立即获得执行结果

**考虑的替代方案**：
- 异步执行模式：需要任务队列、状态轮询等，复杂度高
- **选择**：同步模式，未来可以扩展为异步模式

### 决策 2：业务接口配置方式

**决策**：ServiceTask 的业务接口 URL 通过 BPMN 扩展属性配置（使用 `xflow:` 命名空间）。

**理由**：
- 符合 BPMN 2.0 扩展机制
- 配置与流程定义一起存储
- 便于流程设计时配置

**考虑的替代方案**：
- 独立配置表：需要额外的数据库表和管理界面
- **选择**：BPMN 扩展属性，更符合 BPMN 标准

### 决策 3：条件表达式语言

**决策**：使用 `github.com/antonmedv/expr` 库评估条件表达式。

**理由**：
- 轻量级，性能好
- 支持常见的表达式语法
- 安全性好（沙箱执行）
- 易于集成

**考虑的替代方案**：
- JavaScript 引擎（如 `github.com/robertkrimen/otto`）：功能强大但体积大
- 自定义表达式解析器：开发成本高
- **选择**：expr 库，平衡功能和复杂度

### 决策 4：流程推进策略

**决策**：单步推进，每次执行接口调用只推进一步（从一个节点到下一个节点）。

**理由**：
- 简化实现
- 便于调试和错误处理
- 客户端可以控制执行节奏

**考虑的替代方案**：
- 自动推进到 EndEvent：复杂度高，难以处理用户任务和等待事件
- **选择**：单步推进，更灵活

## 架构设计

### 服务层结构

```
WorkflowEngineService
├── ExecuteFromNode() - 主执行方法
├── executeNode() - 执行单个节点
│   ├── executeServiceTask() - 执行 ServiceTask
│   ├── executeUserTask() - 处理 UserTask
│   ├── executeGateway() - 处理 Gateway
│   └── executeEndEvent() - 处理 EndEvent
├── advanceToNextNode() - 推进到下一个节点
├── evaluateCondition() - 评估条件表达式
└── callBusinessAPI() - 调用业务接口
```

### 数据流

1. **请求处理**：
   ```
   HTTP Request (POST /api/execute/:instance_id)
   → Handler.ExecuteWorkflow()
   → WorkflowEngineService.ExecuteFromNode()
   ```

2. **执行流程**：
   ```
   ExecuteFromNode()
   → 获取实例和定义
   → 解析 BPMN XML
   → 验证 fromNodeId
   → executeNode(fromNodeId)
   → advanceToNextNode()
   → 更新实例和执行记录
   → 返回结果
   ```

3. **业务接口调用**（ServiceTask）：
   ```
   executeServiceTask()
   → 获取业务接口 URL（从节点扩展属性）
   → callBusinessAPI(url, businessParams)
   → 存储响应到 variables
   → 返回业务响应
   ```

### 响应结构

```json
{
  "success": true,
  "data": {
    "businessResponse": {
      "statusCode": 200,
      "body": {...},
      "headers": {...}
    },
    "engineResponse": {
      "instanceId": "uuid",
      "currentNodeIds": ["node_1"],
      "nextNodeIds": ["node_2"],
      "status": "running",
      "executionId": "uuid",
      "variables": {...}
    }
  }
}
```

## 风险 / 权衡

### 风险 1：业务接口调用失败

**风险**：外部业务接口可能不可用或返回错误，导致工作流执行失败。

**缓解措施**：
- 实现超时机制
- 记录详细的错误信息
- 将执行状态标记为 `failed`，允许重试

### 风险 2：条件表达式安全性

**风险**：恶意或错误的表达式可能导致安全问题或执行错误。

**缓解措施**：
- 使用沙箱表达式评估库（expr）
- 限制表达式可访问的变量
- 捕获表达式评估错误

### 风险 3：并发执行冲突

**风险**：多个请求同时执行同一个实例可能导致状态不一致。

**缓解措施**：
- 使用数据库事务
- 使用乐观锁（通过 `instance_version`）
- 在应用层加锁（如果必要）

### 权衡

- **简单性 vs 功能完整性**：选择简单实现，优先支持核心功能，复杂功能（如并行网关）后续扩展
- **同步 vs 异步**：选择同步模式，简化实现，但限制了长时间运行的工作流
- **配置灵活性 vs 实现复杂度**：选择 BPMN 扩展属性，配置简单但需要扩展解析器

## 迁移计划

### 阶段 1：核心功能（MVP）
1. 实现基本的节点执行逻辑
2. 实现简单的流程推进（序列流）
3. 实现 ServiceTask 业务接口调用
4. 基本的错误处理

### 阶段 2：增强功能
1. 条件表达式支持（ExclusiveGateway）
2. 更完善的错误处理
3. 执行记录详细日志

### 阶段 3：扩展功能（未来）
1. 并行网关支持
2. 异步执行模式
3. 子流程支持

## 未决问题

1. **业务接口认证**：如何传递认证信息（API Key、Token 等）？
   - 方案 A：在 BPMN 扩展属性中配置
   - 方案 B：使用系统配置的认证信息
   - **待决定**：先实现方案 A，后续根据需求调整

2. **业务接口超时时间**：默认超时时间是多少？
   - **暂定**：30 秒

3. **变量作用域**：业务接口响应如何与工作流变量合并？
   - **暂定**：将业务接口响应存储到 `variables.businessResponse` 中，同时可以提取特定字段到顶层变量

4. **UserTask 处理**：UserTask 节点如何标记为完成？
   - **暂定**：UserTask 执行后返回待处理状态，需要单独的接口来标记完成（不在本次实现范围内）

